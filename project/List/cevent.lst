C251 COMPILER V5.60.0,  cevent                                                             27/01/24  11:12:03  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE cevent
OBJECT MODULE PLACED IN .\List\cevent.obj
COMPILER INVOKED BY: G:\KEIL_CORE\C251\BIN\C251.EXE ..\user\src\cevent.c XSMALL INTR2 BROWSE INCDIR(..\driver\include;..
                    -\peripheral\header;..\user\include) DEBUG PRINT(.\List\cevent.lst) OBJECT(.\List\cevent.obj) 

stmt  level    source

    1          /**
    2           * @file cevent.c
    3           * @author Letter (nevermindzzt@gmail.com)
    4           * @brief c event
    5           * @version 1.0.0
    6           * @date 2020-11-15
    7           * 
    8           * @copyright (c) 2020 Letter
    9           * 
   10           */
   11          //#include "cevent.h"
   12          #include "config.h"
   13          
   14          #if defined(__CC_ARM) || (defined(__ARMCC_VERSION) && __ARMCC_VERSION >= 6000000)
                   extern const size_t cEvent$$Base;
                   extern const size_t cEvent$$Limit;
               #elif defined(__ICCARM__) || defined(__ICCRX__)
                   #pragma section="cEvent"
               #elif defined(__GNUC__)
                   extern const size_t _cevent_start;
                   extern const size_t _cevent_end;
               #endif
   23          
   24          #if (CEVENT_SPEED_OPTIMIZE == 1 && CEVENT_BUFFER_SIZE > 0)
   25          static size_t ceventBuffer[CEVENT_BUFFER_SIZE] = {0};
   26          #endif
   27          
   28          /**
   29           * @brief cevent注册表
   30           */
   31          struct 
   32          {
   33          #if (CEVENT_SPEED_OPTIMIZE == 1)
   34              size_t **eventBase;                 /**< 事件基址 */
   35          #else
                   CEvent *base;                       /**< 表基址 */
                   size_t count;                       /**< 表大小 */
               #endif
   39          } ceventTable;
   40          
   41          /**
   42           * @brief cevent初始化
   43           */
   44          void ceventInit(void)
   45          {
   46   1          CEvent *base;
   47   1          size_t count;
   48   1              size_t i,j;
   49   1              size_t *cur;
   50   1              size_t *ceventBuffer;
   51   1      #if defined(__CC_ARM) || (defined(__ARMCC_VERSION) && __ARMCC_VERSION >= 6000000)
                   base = (CEvent *)(&cEvent$$Base);
                   count = ((size_t)(&cEvent$$Limit) - (size_t)(&cEvent$$Base)) / sizeof(CEvent);
               #elif defined(__ICCARM__) || defined(__ICCRX__)
                   base = (CEvent *)(__section_begin("cEvent"));
                   count = ((size_t)(__section_end("cEvent")) - (size_t)(__section_begin("cEvent")))
                           / sizeof(CEvent);
               #elif defined(__GNUC__)
C251 COMPILER V5.60.0,  cevent                                                             27/01/24  11:12:03  PAGE 2   

                   base = (CEvent *)(&_cevent_start);
                   count = ((size_t)(&_cevent_end) - (size_t)(&_cevent_start)) / sizeof(CEvent);
               #else
   62   1      //    #error not supported compiler, please use command table mode
   63   1      #endif
   64   1      
   65   1      #if CEVENT_SPEED_OPTIMIZE == 1
   66   1          size_t maxEvent = 0;
   67   1          for (i = 0; i < count; i++)
   68   1          {
   69   2              if (base[i].event > maxEvent) {
   70   3                  maxEvent = base[i].event;
   71   3              }
   72   2          }
   73   1          maxEvent += 1;
   74   1      #if CEVENT_BUFFER_SIZE <= 0
                   ceventBuffer = CEVENT_MALLOC(((maxEvent << 1) + count) * sizeof(size_t));
               #endif /** CEVENT_BUFFER_SIZE <= 0 */
   77   1          ceventTable.eventBase = (size_t **) ceventBuffer;
   78   1          cur = ceventBuffer + maxEvent;
   79   1          for (i = 0; i < maxEvent; i++)
   80   1          {
   81   2              ceventTable.eventBase[i] = cur;
   82   2              for (j = 0; j < count; j++)
   83   2              {
   84   3                  if (base[j].event == i) {
   85   4                      *cur++ = (size_t) &base[j];
   86   4                  }
   87   3              }
   88   2              *cur++ = NULL;
   89   2          }
   90   1      #else /** CEVENT_SPEED_OPTIMIZE == 1 */
                   ceventTable.base = base;
                   ceventTable.count = count;
               #endif
   94   1      }
   95          
   96          /**
   97           * @brief cevent运行
   98           * 
   99           * @param cevent cevent
  100           * 
  101           */
  102          static void ceventRun(CEvent *cevent)
  103          {
  104   1              void (*function)(void *,...)        reentrant;
  105   1              void (*function_void)();
  106   1          if (cevent->paramNum < 1)
  107   1          {
  108   2              return;
  109   2          }
  110   1              function = (void (*)(void *,...))(cevent->param[0]);
  111   1          switch (cevent->paramNum)
  112   1              {
  113   2                      case 1:
  114   2                              function_void =(void (*)())(cevent->param[0]);
  115   2                              function_void();
  116   2                              break;
  117   2                      case 2:
  118   2                              function(cevent->param[1]);
  119   2                              break;
  120   2                      case 3:
  121   2                              function(cevent->param[1], cevent->param[2]);
  122   2                              break;
  123   2                      case 4:
  124   2                              function(cevent->param[1], cevent->param[2], cevent->param[3]);
C251 COMPILER V5.60.0,  cevent                                                             27/01/24  11:12:03  PAGE 3   

  125   2                              break;
  126   2                      case 5:
  127   2                              function(cevent->param[1], cevent->param[2], cevent->param[3], cevent->param[4]);
  128   2                              break;
  129   2                      case 6:
  130   2                              function(cevent->param[1], cevent->param[2], cevent->param[3], cevent->param[4],
  131   2                                               cevent->param[5]);
  132   2                              break;
  133   2                      case 7:
  134   2                              function(cevent->param[1], cevent->param[2], cevent->param[3], cevent->param[4],
  135   2                                               cevent->param[5], cevent->param[6]);
  136   2                              break;
  137   2                      case 8:
  138   2                              function(cevent->param[1], cevent->param[2], cevent->param[3], cevent->param[4],
  139   2                                               cevent->param[5], cevent->param[6], cevent->param[7]);
  140   2                              break;
  141   2                      default:
  142   2                              break;
  143   2          }
  144   1      }
  145          
  146          /**
  147           * @brief cevent处理
  148           * 
  149           * @param event 事件
  150           * 
  151           */
  152          static void ceventHandler(unsigned short event)
  153          {
  154   1      #if CEVENT_SPEED_OPTIMIZE == 1
  155   1          CEvent **cevent = (CEvent **) ceventTable.eventBase[event];
  156   1          while (*cevent != NULL)
  157   1          {
  158   2              ceventRun(*cevent++);
  159   2          }
  160   1      #else
                   for (size_t i = 0; i < ceventTable.count; i++)
                   {
                       if (ceventTable.base[i].event == event)
                       {
                           ceventRun(&(ceventTable.base[i]));
                       }
                   }
               #endif
  169   1      }
  170          
  171          /**
  172           * @brief 广播event事件
  173           * 
  174           * @param event 事件
  175           * 
  176           */
  177          void ceventPost(unsigned short event)
  178          {
  179   1          ceventHandler(event);
  180   1      }
  181          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       758     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
C251 COMPILER V5.60.0,  cevent                                                             27/01/24  11:12:03  PAGE 4   

  xdata-const size     =    ------     ------
  edata size           =       132         10
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       132     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
